<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>OrbitXE Annotation Overlay</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }

    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: transparent;
      -webkit-app-region: no-drag;
      pointer-events: none;
    }

    #canvas {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
    }
  </style>
</head>
<body>
  <canvas id="canvas"></canvas>

  <script>
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    // Track active strokes
    const strokes = new Map();
    const shapes = new Map();
    let shapeId = 0;

    // Resize canvas to screen size
    function resize() {
      canvas.width = window.innerWidth;
      canvas.height = window.innerHeight;
      redrawAll();
    }

    window.addEventListener('resize', resize);
    resize();

    // Convert normalized (0-1) to screen coordinates
    function toScreen(x, y) {
      return {
        x: x * canvas.width,
        y: y * canvas.height
      };
    }

    // Draw a single stroke
    function drawStroke(stroke) {
      if (stroke.points.length < 2) return;

      ctx.beginPath();
      ctx.strokeStyle = stroke.color || '#00ff88';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Apply fade based on remaining time
      const elapsed = Date.now() - stroke.startTime;
      const fadeStart = 7000;
      const totalTime = 10000;

      if (elapsed > fadeStart) {
        const fadeProgress = (elapsed - fadeStart) / (totalTime - fadeStart);
        ctx.globalAlpha = Math.max(0, 1 - fadeProgress);
      } else {
        ctx.globalAlpha = 1;
      }

      const first = toScreen(stroke.points[0].x, stroke.points[0].y);
      ctx.moveTo(first.x, first.y);

      for (let i = 1; i < stroke.points.length; i++) {
        const pt = toScreen(stroke.points[i].x, stroke.points[i].y);
        ctx.lineTo(pt.x, pt.y);
      }

      ctx.stroke();
      ctx.globalAlpha = 1;
    }

    // Draw a shape
    function drawShape(shape) {
      ctx.beginPath();
      ctx.strokeStyle = shape.color || '#00ff88';
      ctx.lineWidth = 4;
      ctx.lineCap = 'round';
      ctx.lineJoin = 'round';

      // Apply fade
      const elapsed = Date.now() - shape.startTime;
      const fadeStart = 7000;
      const totalTime = 10000;

      if (elapsed > fadeStart) {
        const fadeProgress = (elapsed - fadeStart) / (totalTime - fadeStart);
        ctx.globalAlpha = Math.max(0, 1 - fadeProgress);
      } else {
        ctx.globalAlpha = 1;
      }

      const p1 = toScreen(shape.x1, shape.y1);

      if (shape.shape === 'rect') {
        const p2 = toScreen(shape.x2, shape.y2);
        ctx.strokeRect(p1.x, p1.y, p2.x - p1.x, p2.y - p1.y);
      } else if (shape.shape === 'circle') {
        const radius = shape.radius * Math.min(canvas.width, canvas.height);
        ctx.arc(p1.x, p1.y, radius, 0, Math.PI * 2);
        ctx.stroke();
      } else if (shape.shape === 'arrow') {
        const p2 = toScreen(shape.x2, shape.y2);
        ctx.moveTo(p1.x, p1.y);
        ctx.lineTo(p2.x, p2.y);
        ctx.stroke();
        const angle = Math.atan2(p2.y - p1.y, p2.x - p1.x);
        ctx.beginPath();
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p2.x - 20 * Math.cos(angle - Math.PI / 6), p2.y - 20 * Math.sin(angle - Math.PI / 6));
        ctx.moveTo(p2.x, p2.y);
        ctx.lineTo(p2.x - 20 * Math.cos(angle + Math.PI / 6), p2.y - 20 * Math.sin(angle + Math.PI / 6));
        ctx.stroke();
      }

      ctx.globalAlpha = 1;
    }

    // Redraw all active strokes and shapes
    function redrawAll() {
      ctx.clearRect(0, 0, canvas.width, canvas.height);

      const now = Date.now();

      for (const [id, stroke] of strokes) {
        if (now - stroke.startTime < 10000) {
          drawStroke(stroke);
        }
      }

      for (const [id, shape] of shapes) {
        if (now - shape.startTime < 10000) {
          drawShape(shape);
        }
      }
    }

    // Handle drawing messages from main process
    console.log('Overlay: Setting up message listener');
    window.electronAPI.onDrawMessage((msg) => {
      console.log('Overlay received:', msg.type, msg);
      switch (msg.type) {
        case 'draw-start':
          strokes.set(msg.strokeId, {
            points: [{ x: msg.x, y: msg.y }],
            color: msg.color,
            startTime: Date.now()
          });
          setTimeout(() => {
            strokes.delete(msg.strokeId);
            redrawAll();
          }, 10000);
          break;

        case 'draw-move':
          const stroke = strokes.get(msg.strokeId);
          if (stroke) {
            stroke.points.push({ x: msg.x, y: msg.y });
            redrawAll();
          }
          break;

        case 'draw-end':
          redrawAll();
          break;

        case 'draw-shape':
          const id = shapeId++;
          shapes.set(id, {
            ...msg,
            startTime: Date.now()
          });
          redrawAll();
          setTimeout(() => {
            shapes.delete(id);
            redrawAll();
          }, 10000);
          break;

        case 'clear':
          strokes.clear();
          shapes.clear();
          redrawAll();
          break;
      }
    });

    // Continuous redraw for smooth fading
    function animate() {
      redrawAll();
      requestAnimationFrame(animate);
    }
    animate();
  </script>
</body>
</html>
